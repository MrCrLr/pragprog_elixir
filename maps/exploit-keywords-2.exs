defmodule Exploit do
  @defaults [
    baseurl: "fun.com/",
    endpoint: "toys?productid=",
    payload: "sql",
    workers: 1,
    style: []
  ]

  def proof(text, options \\ []) do
    # Merge user options with defaults (keeps repeated keys)
    options = Keyword.merge(@defaults, options)

    # Check for required keys using has_key?
    unless Keyword.has_key?(options, :baseurl) do
      raise ArgumentError, "Missing required option: :baseurl"
    end

    # Extract a value using fetch (returns {:ok, value})
    {:ok, endpoint} = Keyword.fetch(options, :endpoint)

    # Extract something using fetch!
    payload = Keyword.fetch!(options, :payload)

    # Pop a value (remove and retrieve)
    {workers, options_without_workers} = Keyword.pop(options, :workers)

    # Put a synthetic key back in
    options_with_meta =
      Keyword.put(options_without_workers, :meta, "auto-generated")

    # Delete a noisy key (example)
    options_clean =
      Keyword.delete(options_with_meta, :debug)

    IO.puts "Proof of concept: #{inspect(text)}"

    IO.puts "Base URL: #{options[:baseurl]}"
    IO.puts "Endpoint: #{endpoint}"
    IO.puts "Payload: #{payload}"
    IO.puts "Workers: #{workers}"

    # Repeated styles
    IO.puts "Styles: #{inspect Keyword.get_values(options, :style)}"

    # Print all keys and values (just to show them)
    IO.puts "All keys: #{inspect Keyword.keys(options_clean)}"
    IO.puts "All values: #{inspect Keyword.values(options_clean)}"

    IO.puts "Options after cleanup: #{inspect options_clean}"
  end
end

Exploit.proof(
  "cve-xxx-xxxx",
  baseurl: "example.com/",
  workers: 10,
  style: :brute,
  style: :throttle,
  debug: true
)
